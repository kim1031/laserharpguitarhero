     <meta charset="utf-8" emacsmode="-*- markdown -*-"><link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/slate.css?">

                        **Laser Harp Guitar Hero**
              Julia Gonik, Tiffany Huang, Hyunji Kim, and Joie Le
                                 Team 77
            


Overview
==============================================================

One of our favorite childhood games is Guitar Hero. One day, whilst reminiscing about the carefree joys of youth, we decided that there was no better way to pay homage to a classic video game like Guitar Hero than to recreate it with an EECS embedded systems twist. Thus, Laser Harp Guitar Hero was born. Instead of pressing buttons and strumming on a contrived, cliche guitar-shaped game controller, users break lasers in order to "pluck" the laser harp and play notes. Players choose from a plethora of songs, including classic Guitar Hero tunes in addition to some of our present-day favorites. The user earns a score based on how well they pluck the notes at the appropriate times, and the system keeps track of the user's name and scores in a server-side database that contains leaderboards for each song. Challenge your friends and determine the true laser harp master!

Below is a video of our group demonstrating the game. How fun!

![A demo video! Watch Julia struggle!](https://youtu.be/lB0uD_ifc4c)

System Design
==============================================================
Below is an overview of the design of our system. The vast majority of our project code was written for the ESP32 because that is where most of the game logic is handled. The python server code was mostly used for storing persistent data in databases, including note information for songs and user's scores for the leaderboards. In addition, we also wrote helper functions in Python that allowed us to easily create new note mappings for songs using our computers' keyboards instead of having to figure out note timings manually, which would be tedious.

Software
--------------------------------------------------------------

<big>**Server-Side and Helper Code**</big>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
leaderboards.py
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This code lives on the server and handles get requests for obtaining leaderboard information and post requests for adding new information to the leaderboards database. This is all handled in the appropriately named request_handler function. First, we create a connection to our leaderboards database. Then,if the scores_table does not already exist, we create it. This table has three columns: a score column, a song name column, and a username column. We then take the values from the body of the post request and insert them into their respective columns. In paticular, the body of the post request should have three keys: 'score', 'song', and 'user'. We then close our connection to the database, and the post request is complete. If the request was instead a get request, we follow a similar process. First, we extract the name of the song that we want the leaderboards. This name should come from the query argument 'song'. Then, we get all of the rows in the database with that song name and order them in descending order by score. This is so that it will be easier to display the top scores in order on the ESP32 display. In addition, we only want the top ten scores, so we limit our results to ten rows. Then, we create a string called 'outs' that will hold the output that we want to send back to the ESP32. After that, we iterate over all the rows that we retrieved from the database and add them to the outs string with the following format: "[score,username]". Thus, if your username is joules and you got a score of 18, the format would be "[18,joules]". Multiple scores are represented as follows: "[55,user1] [17,user3] [3,user2]." Finally, we close our connection to the database and return this string to the ESP32 for parsing.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_song.py
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This code is also on the server. It handles get requests that are sent when the user has selected a song and the ESP32 now needs to retrieve the note mapping for that song. This functionality occurs in the request_handler function. First, we check that the request is a get request, since this code is only designed to return values from our database rather than post any new values to the server. After that, we connect to our songs database and retrieve the name of the song from the request. In particular, the name of the song is found in a query argument called 'song'. Next, we get all of the values from the table with the same name as the song in our database. This database contains information about all of the notes that are played during a song. It stores which of the four notes is played, the time it started playing, and its duration. See song_timing.py for more information about how we obtain and store this information. Then, we close the connection to the database and return our results as a string to the ESP32 for parsing.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_songlist.py
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This file lives on the server and works to handle get requests for information about all of the songs that we have created notes for. Particularly, when a get request is made to this file, it returns a list containing the song name, artist name, and song duration for each song in the database. All of this logic is handled in the request_handler function. First, we establish a connection to our database. Then, we select all of the values from the table called songlist. This table has 3 columns: a column for the song name, a column for the artist name, and a column for the song duration. After fetching all of the rows from this table, we close our connection to the database and return the table information to the ESP32 as a string for further parsing and use.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
song_timing.py
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*TO-DO*


<big>**ESP32 Libraries and Classes**</big>



Hardware
--------------------------------------------------------------

Parts List
==============================================================
- 1 ESP32 Microcontroller
- 1 Breadboard
- 1 Micro USB Cable
- 1 Adafruit 5.0" 40-pin TFT Display: 800x480 pixels
- 1 RA8875 Driver Board for 40-pin TFT Touch Displays
- 1 Adafruit 3" Diameter Speaker (4 Ohm 3 Watt)
- 1 DFPlayer Mini MP3 Player
- 1 Micro SD Card
- 4 LEDs (1 green, 1 red, 1 yellow, and 1 blue)
- 4 Lasers
- 4 Phototransistors
- 8 4.7 kÎ© Resistors
- 4 12" blocks of wood
- 1 12" x 12" piece of acrylic
- Wires of various lengths
- 8 Screws
- 4 Nuts
- Electrical tape
- Hot glue
- Shrink wrap
- Zip ties

The 5.0" 40-pin TFT Display and the driver board display the whole graphic user interface for our game. The speaker, MP3 player, and micro SD Card are required to play music. Lasers and phototransistors serve as the strings of the harp. The LEDs help signal a user to break a particular laser at the appropriate time. In addition, both the phototransistors and LEDs require resistors for proper wiring. Finally, we used the wood, acrylic, screws, and nuts to make the laser harp's frame.

Wiring Schematic
--------------------------------------------------------------


State Machine Block Diagram
--------------------------------------------------------------
![Figure [state machine]: State machine diagram of our game](./images/state_machine.png width="800px")

**1. Start:** A simple state that just provides a title screen for the game. When the user breaks the first (leftmost) laser, we move onto the "Enter Username" state.

**2. Enter Username:** Users select their username using the first three lasers. The first laser scrolls backwards through the alphabet while the second laser scrolls forwards through the alphabet. The third laser is used to select a letter. The user breaks the fourth (rightmost) laser to confirm their name and move to the "Choose Song" state. 

**3. Choose Song:** Users select the song they want to play using the first two lasers. The first laser scrolls backwards through the song list, while the second laser scrolls forward through the song list. Information about each song is displayed, including the name of the song, the song's artist, and its duration in seconds. The user breaks the third laser to select a song and move onto the "Play" state.

**4. Play:** This is the state where the actual game occurs. First, the notes for the selected song are retrieved from the server via a get request. Next, the notes are displayed on the screen as colored rectangles, and the user must break the appropriate laser when each rectangular note reaches the bottom of the screen. The user earns points based on how accurately they break the lasers. Once all of the song's notes have been played, the game moves to the "Show Score" state. 

**5. Show Score:** The user's score is stored in the leaderboards database via a post request. In addition, the score is printed to the screen along with further instructions. When the first laser is broken, the song is replayed and we move to the "Play Again" state. When the second laser is broken, the user can select another song to play with the same username, and we move to the "New Song" state. When the third laser is broken, the user can view leaderboards for that particular song, and we move to the "Leaderboard" state. When the fourth laser is broken, the user starts a new game with a new username, and we move to the "Start" state. 

**6. Play Again:** We keep the same song and user info and automatically move to the "Play" state.

**7. New Song:** We keep the same username but clear the song information and automatically move to the "Choose Song" state.

**8. Leaderboard:** We retrieve the leaderboard information for the specified song via a get request to our server-side database and display it on the screen. When the first laser is broken, the user plays the same song again and we move to the "Play Again" state. When the second laser is broken, the user selects another song to play with the same username, and we move to the "New Song" state. Finally, when the third laser is broken, the user starts a new game with a new username, and we move to the "Start" state.

Functional Block Diagram
--------------------------------------------------------------

System Overview
--------------------------------------------------------------


Harp Code
==============================================================

example for how to write code nicely
```````````````````````````````````````````````
count_lines () {
  local f=$1  
  local m
  m=`wc -l $f | sed 's/^\([0-9]*\).*$/\1/'`
  return $m
}
```````````````````````````````````````````````

[Link to nowhere](nowhere). -- link all python files this way


Harp Frame
==============================================================
To create a rectangular frame, 4 blocks of wood was used. On the top and bottom pieces of wood, 4 pairs of holes were drilled spaced evenly such that each pair of holes would align vertically with each other. On the top holes, lasers were put in and photoresistors were put in on the bottom. LED holes were made perpendicular to the holes made for lasers on the top piece of wood such that once the LEDs are put in, the user sitting at the front will be able to see them.

To allow the user to have view of the screen and mount the speaker, a piece of acrylic was used. From a rectangular piece of acrylic, two pieces, a rectangle big enough to show the screen and a circle to fit the speaker was cut out to create a design shown as below:

A 3D printed screen holder was used to secure the screen to acrylic. The design of the screen holder is as shown below:


Decision Making and Challenges
==============================================================

Alignment of Lasers and Phototransistors
--------------------------------------------------------------
Our game relies heavily on being able to detect whether or not a laser is broken. For instance, the player must break the laser at the correc time in order to gain points while playing the song. We also use broken lasers as a means of navigating from one page to the other and even selecting a username. Thus, it is crucial that the detection of broken lasers is very accurate. In order to achieve this accuracy, we had to make sure that each laser is pointed exactly at its corresponding phototransistor and that it stayed that way even when we moved the laser harp or the harp was bumped or jostled. We first considered this issue when building the laser harp frame. Firstly, when drilling the holes in the wood for where the lasers and phototransistors would be placed, we tried our very best to make sure that the holes were aligned vertically on top of each other. This was a bit challenging since none of us had much experience with woodwork or power tools, but Tiffany and her MakerLodge training were key. Next, we tried to drill the holes so their diameters were as close as possible to the diameters of the lasers and phototransistors in order to ensure a snug fit. This was also quite difficult because drillbits only come in predetermined sizes, so the holes were a bit too large. In order to attempt to stabilize the lasers and phototransistors, we first tried simply wrapping them in electrical tape in order to increase their diameters so that they fit more snugly inside the holes. However, this didn't work very well because the lasers would still shift over time and could easily be jostled out of position. Thus, we decided to use a combination of this taping method in addition to hot glue. Once the lasers were taped and placed in a position that we liked, we hot glued the top of the wire that stuck out of the hole onto the wooden frame. This still wasn't completely perfect, and some of the lasers had to be adjusted at times, but it worked very reliably for our purposes. For the phototransistors, we decided to forgo the electrical tape and solely use hot glue to secure them since their diameters were already pretty small, so you would have to use a lot of tape to make them fit securely in the holes. We first tested to make sure that phototransistors' measured voltage still changed reliably even when hot glue was placed on top of them. We found that the hot glue had no significant effect on the phototransistors' performance, so we went ahead with our plan. First, we turned on the lasers so we could see where the phototransistors should be placed. Then, we placed hot glue on each phototransistor and secured them to our liking. We also glued the wires that stuck out of the wooden frame into place as well. Thus, our lasers and phototransistors were beautifully aligned and secured!

The Wiring
--------------------------------------------------------------
Having to connect so many wires to the breadboard specifically for the LEDs, lasers, and phototransistors, the wiring often became very messy and it was difficult to find out whether the wiring was done incorrectly or if a wire had been accidently taken out, not to mention the numerous times in which the wires broke. 

In order to prevent such difficulties, we color-coded wires and twisted pairs of wires that go to the same piece. Wires for similar pieces were then also grouped together using tape and zip ties. For lasers, white wires went to power and black wires went to ground. For each 'string,' we attributed different colors, green, red, yellow, and blue, which we represented with LEDs. Wires for the phototransistors were hence set such that white wires always go to power and the wire that goes to the ESP32 is the same as the color it is assigned. Finally, for the LEDs, black wires were used to go to power and accordingly colored wires went to the ESP32. 

MP3 Player
--------------------------------------------------------------

Screen
--------------------------------------------------------------



Energy Management
==============================================================




 
<style class="fallback">body{visibility:hidden}</style><script>markdeepOptions={tocStyle:'none'};</script>
<!-- Markdeep: --><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>
